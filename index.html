<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Keyboard Layout</title>
    <style>
        body {
            background: rgba(0,0,0,1);
            font-family: Arial, sans-serif;
            position: relative;
        }

        #keyboard {
            margin: 0 auto;
            position: relative;
            background: rgba(0,0,0,1);
            border: 10px solid #999;
        }

        .keycap {
            position: absolute;
            border: 0px solid #333;
            background-color: rgba(30,30,30,1);
            border-radius: 3px;
            display: flex;
            z-index:1;
            visibility: hidden;
        }

        .led{
            position: absolute;
            border: 0px;
            background-color: red;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            mix-blend-mode: screen;
            z-index:0;
            //display: none;
        }

        #ctrlPad {
            margin: 0 auto;
            position: relative;
            background: rgba(60,60,60,1);
            border: 1px solid #999;

            display: grid;
            grid-template-columns: repeat(5, 1fr); /* 5 欄，每欄平均寬 */
            grid-template-rows: auto;         /* 1 列，自動高度 */
            gap: 10px;                             /* 格子間距 */
            padding: 10px;
            color: white;
        }

        .cell {
            border: 1px solid #555;
            border-radius: 5px;
            padding: 8px;
            text-align: center;

            display: grid;
            grid-template-columns: repeat(1, 1fr);      /* 1 欄，每欄平均寬 */
            grid-template-rows: auto auto auto auto;    /* 4 列，自動高度 */
            gap: 1px;                                  /* 格子間距 */
            padding: 10px;
            color: white;
        }
        .cell2{
            border: 0px solid #555;
            padding: 8px;
            text-align: center;
        }

        .color_chooser{
            border-radius: 10px;
            border: 0px solid #999;
            background: rgba(200,200,200,0.2);
        }

    </style>
</head>

<body>


<div id="keyboard"></div>
<canvas id="ccanvas"></canvas>

<div id="ctrlPad">
    <div class="cell">
        <div class="cell2">
            <label for="combo_dis">Display Mode:</label>
            <select id="combo_dis">
              <option value="dis_Keycap">Keycap</option>
              <option value="dis_Led">Led</option>
            </select>
        </div>
    </div>

    <div class="cell">
        <div class="cell2">
            <label for="bar_edge_w">Keycap Edge:</label>
            <input type="range" id="bar_edge_w" min="0" max="4" step = "0.5" value="2">
        </div>
        <div class="cell2">
            <label for="bar_round_rate">Keycap Round:</label>
            <input type="range" id="bar_round_rate" min="0.5" max="20" step = "0.5" value="5">
        </div>
        <div class="cell2">
            <button id="btn_ss" class = "Btn" id="startBtn" >測試按鈕</button>
        </div>


    </div>

    <div class="cell">
        <div class="cell2">
            <label for="keycap_color_chooser">Keycap Color：</label>
            <input class = "color_chooser" type="color" id="keycap_color_chooser" value="#202020">
        </div>
        <div class="cell2">
            <label for="kb_shell_color_chooser">Shell Color：</label>
            <input class = "color_chooser" type="color" id="kb_shell_color_chooser" value="#202020">
        </div>
        <div class="cell2"></div>
        <div class="cell2"></div>
    </div>
    <div class="cell"></div>
    <div class="cell">
        <div class="cell2">
            <label for="combo_mode">Effect Mode:</label>
            <select id="combo_mode">
              <option value="_NUM_BootupA">HP_BootA</option>
              <option value="_NUM_BootupB">HP_BootB</option>
              <option value="_NUM_Ripple">HP_Ripple</option>
              <option value="_NUM_Starlight">HP_Starlight</option>
              <option value="_NUM_Basic_single_color_sweep">Sweep</option>
              <option value="_NUM_static">Static</option>
            </select>
        </div>
        <div class="cell2">
            <label for="combo_color">Color:</label>
            <select id="combo_color">
              <option value="0">Close</option>
              <option value="1">Red</option>
              <option value="2">Green</option>
              <option value="3">Blue</option>
              <option value="4">Yellow</option>
              <option value="5">Ice</option>
              <option value="6">Pink</option>
              <option value="7">White</option>
              <option value="8">Orange</option>
            </select>
        </div>
    </div>
</div>
<script src="main.js"></script>
<script>

const effect_num = {
    _NUM_BootupA :          0,
    _NUM_BootupB :          1,
    _NUM_Starlight :        2,
    _NUM_Ripple :           3,
    _NUM_Basic_single_color_sweep :    4,
    _NUM_static :           5
    };

const HIDCodeMap = {
      KeyA: 0x04,
      KeyB: 0x05,
      KeyC: 0x06,
      KeyD: 0x07,
      KeyE: 0x08,
      KeyF: 0x09,
      KeyG: 0x0A,
      KeyH: 0x0B,
      KeyI: 0x0C,
      KeyJ: 0x0D,
      KeyK: 0x0E,
      KeyL: 0x0F,
      KeyM: 0x10,
      KeyN: 0x11,
      KeyO: 0x12,
      KeyP: 0x13,
      KeyQ: 0x14,
      KeyR: 0x15,
      KeyS: 0x16,
      KeyT: 0x17,
      KeyU: 0x18,
      KeyV: 0x19,
      KeyW: 0x1A,
      KeyX: 0x1B,
      KeyY: 0x1C,
      KeyZ: 0x1D,
      Digit1: 0x1E,
      Digit2: 0x1F,
      Digit3: 0x20,
      Digit4: 0x21,
      Digit5: 0x22,
      Digit6: 0x23,
      Digit7: 0x24,
      Digit8: 0x25,
      Digit9: 0x26,
      Digit0: 0x27,
      Enter: 0x28,
      Escape: 0x29,
      Backspace: 0x2A,
      Tab: 0x2B,
      Space: 0x2C,
      ArrowRight: 0x4F,
      ArrowLeft: 0x50,
      ArrowDown: 0x51,
      ArrowUp: 0x52
    };

    let elec_max_row;
    let elec_max_col;
    let R_value_src = [];
    let G_value_src = [];
    let B_value_src = [];
    let LED_Run_Mode_start;
    let main_color;

    let led_effect_main;
    let key_reactive;


    Module.onRuntimeInitialized = function() {
        // 使用 cwrap 產生 JS 可呼叫的函式介面
        led_effect_main = Module.cwrap('led_effect_main', 'void', []);
        key_reactive = Module.cwrap('key_reactive', 'void', ['number']);
        const get_share_buf_ptr = Module.cwrap('get_share_buf_ptr','number',[]);

        const elec_max_row_addr_start = get_share_buf_ptr();
        const elec_max_col_addr_start = get_share_buf_ptr();
        const R_addr_start = get_share_buf_ptr();
        const G_addr_start = get_share_buf_ptr();
        const B_addr_start = get_share_buf_ptr();
        const LED_Run_Mode_start_addr_start = get_share_buf_ptr();
        const main_color_addr_start = get_share_buf_ptr();

        // 建立一個對 WASM memory 的視窗（Uint8Array）
        // 長度 = count * stride
        elec_max_row= new Uint8Array(Module.HEAPU8.buffer, elec_max_row_addr_start, 1);
        elec_max_col= new Uint8Array(Module.HEAPU8.buffer, elec_max_col_addr_start, 1);
        elec_max_row = elec_max_row[0];
        elec_max_col = elec_max_col[0];

        R_value_src = new Uint8Array(Module.HEAPU8.buffer, R_addr_start, elec_max_row*elec_max_col);
        G_value_src = new Uint8Array(Module.HEAPU8.buffer, G_addr_start, elec_max_row*elec_max_col);
        B_value_src = new Uint8Array(Module.HEAPU8.buffer, B_addr_start, elec_max_row*elec_max_col);
        LED_Run_Mode_start = new Uint8Array(Module.HEAPU8.buffer, LED_Run_Mode_start_addr_start, 1);
        main_color = new Uint8Array(Module.HEAPU8.buffer, main_color_addr_start, 1);

 };

    let led_solid_radius = 14;
    let led_soft_radius = 80;
    let keycap_light_edge_width = 2;
    let keycap_round_rate = 5;

    let max_keycap_x = 0;
    let max_keycap_y = 0;
    let dis_index = 'dis_Keycap';
    const ccanvas = document.getElementById('ccanvas');
    let ctx;
    const led_light_cover = 100;

    const all_keycaps=[];
    const all_leds=[];


    let rr = 255;
    let gg = 255;
    let bb = 0;
    let step = 5;

//----------------------Object Color-----------------------------
    const mainBg = 'rgba(20,20,20,1)';
    let KB_shell_color = 'rgba(50,50,50,1)';
    let Keycap_color = 'rgba(70,70,70,1)';
    let Keycap_edge_color = 'rgb(60,60,60)';

    //--------Draw basic color on something-----------------
        document.body.style.backgroundColor = mainBg;
        keyboard.style.backgroundColor = Keycap_edge_color;

//----------------------json load-----------------------------
    fetch('./KB_source/HP_F_real_elec_pos(S).json')
        .then(response => response.json())
        .then(data => {

            const keyboard = document.getElementById('keyboard');

            data.all_keycap.forEach(key => {
                const keyDiv = document.createElement('div');
                keyDiv.className = 'keycap';
                keyDiv.style.left = key.start_x +keycap_light_edge_width + 10 + 'px';
                keyDiv.style.top = key.start_y +keycap_light_edge_width + 'px';
                keyDiv.style.width = key.width-2*keycap_light_edge_width + 'px';
                keyDiv.style.height = key.height-2*keycap_light_edge_width + 'px';
                keyDiv.textContent = key.icon;
                all_keycaps.push(keyDiv);
                keyboard.appendChild(keyDiv);

                if(key.start_x + key.width > max_keycap_x) max_keycap_x = key.start_x + key.width;
                if(key.start_y + key.height > max_keycap_y) max_keycap_y = key.start_y + key.height;
            });

            document.getElementById("keyboard").style.width = max_keycap_x + 10 +'px';
            document.getElementById("keyboard").style.height = max_keycap_y + 30 +'px';

            data.all_leds.forEach(led_j => {
                const ledDiv = document.createElement('div');
                ledDiv.className = 'led';
                ledDiv.style.left = led_j.x-led_soft_radius + 'px';
                ledDiv.style.top = led_j.y-led_soft_radius + 'px';
                ledDiv.style.width = led_soft_radius*2 + 'px';
                ledDiv.style.height = led_soft_radius*2 + 'px';
                ledDiv.style.background = 'radial-gradient(circle closest-side, rgba(0,0,0,1), rgba(0,0,0,0))';
                ledDiv.row = led_j.scan_row;
                ledDiv.col = led_j.col;
                ledDiv.softx = led_j.x-led_soft_radius;
                ledDiv.softy = led_j.y-led_soft_radius;
                ledDiv.solidx = led_j.x+led_solid_radius/2;
                ledDiv.solidy = led_j.y-led_solid_radius/2;
                keyboard.appendChild(ledDiv);

                const row = led_j.scan_row;
                const col = led_j.col;

                if (!all_leds[row]) {            // if it doesn't exist, build
                    all_leds[row] = [];
                }
                all_leds[row][col] = ledDiv;      // put it in!!!

            });

            keyboard.appendChild(ccanvas);
            ccanvas.style.position = 'absolute';
            ccanvas.style.left = -led_light_cover+'px';
            ccanvas.style.top = -led_light_cover+'px';

            //const dpr = window.devicePixelRatio || 1;
            const dpr = 3;
            const rect = keyboard.getBoundingClientRect();

            // real pixel width,height
            ccanvas.width = (rect.width+led_light_cover*2) * dpr;
            ccanvas.height = (rect.height+led_light_cover*2) * dpr;

            // real size in your eyes
            ccanvas.style.width = rect.width+led_light_cover*2 + 'px';
            ccanvas.style.height = rect.height+led_light_cover*2 + 'px';

            ctx = ccanvas.getContext('2d');
            ctx.scale(dpr, dpr);

            draw_with_keycap();
        //------------call led effect---------------
            const call_led_effect = setInterval(() => {
                led_effect_main();
            }, 20);

        //------------update screen---------------
            const update_screen = setInterval(() => {
                for(let row = 0 ; row < elec_max_row;row++ )
                {
                    for(let col = 0 ;col < elec_max_col; col++)
                    {
                        rr = R_value_src[row*elec_max_col+col];
                        gg = G_value_src[row*elec_max_col+col];
                        bb = B_value_src[row*elec_max_col+col];
                        if(all_leds[row][col] != undefined)
                        {
                            if(dis_index == 'dis_Keycap')all_leds[row][col].style.background =  `radial-gradient(circle closest-side, rgba(${rr},${gg},${bb},1), rgba(0,0,0,0))`;
                            else if(dis_index == 'dis_Led')all_leds[row][col].style.background =`rgba(${rr},${gg},${bb},1)`;
                        }
                    }
                }

            }, 33);
        //------------something control---------------
          /*  const something_control = setInterval(() => {
                static_color[0]++;
                if(static_color[0]>8)static_color[0] = 1;

                //if(LED_Run_Mode_start[0]!==1 && LED_Run_Mode_start[0] !== 0xFF) LED_Run_Mode_start[0] = 1;

            }, 2000);*/

//----------------------------ctrl area------------------------------
            const ctrl_pad = document.getElementById('ctrlPad');
            ctrl_pad.style.top = led_light_cover/2+'px';
            ctrl_pad.style.height = rect.height/2+'px';
            ctrl_pad.style.width = rect.width+'px';

//----------------------------key event------------------------------
            document.addEventListener("keydown", function(event) {
               const hid = HIDCodeMap[event.code];
                key_reactive(hid);
               console.log("按下：" + event.key + "（代碼：" + event.code + "）");


            });


            // 放開鍵時觸發
           /* document.addEventListener("keyup", function(event) {
                console.log("放開：" + event.key);
            });*/


        })
        .catch(error => {
            console.error('讀取 JSON 失敗:', error);
        });

//---------------------------display mode------------------------------
    const combo_dis = document.getElementById('combo_dis');
    combo_dis.addEventListener('change', () => {
        dis_index = combo_dis.value;
        if(dis_index == 'dis_Keycap')
        {
            draw_with_keycap();
        }
        else if(dis_index == 'dis_Led')
        {
            draw_only_led();
        }
    });

//-----------------------choose effect mode--------------------------
    const combo_mode = document.getElementById('combo_mode');
    combo_mode.addEventListener('change', () => {

        LED_Run_Mode_start[0] = effect_num[combo_mode.value];
    });

//-----------------------choose color--------------------------
    const combo_color = document.getElementById('combo_color');
    combo_color.addEventListener('change', () => {
        main_color[0] = combo_color.value;
    });

//-------------------------keycap edge adjust----------------------------
    const bar_edge_w = document.getElementById('bar_edge_w');
    bar_edge_w.addEventListener('input', () => {
        keycap_light_edge_width = parseFloat(bar_edge_w.value);
        if(dis_index == 'dis_Keycap')draw_with_keycap();
        else if(dis_index == 'dis_Led')draw_only_led();
    });

//-------------------------keycap round adjust----------------------------
    const bar_round_rate = document.getElementById('bar_round_rate');
    bar_round_rate.addEventListener('input', () => {
        keycap_round_rate = parseFloat(bar_round_rate.value);
        if(dis_index == 'dis_Keycap')draw_with_keycap();
        else if(dis_index == 'dis_Led')draw_only_led();
    });

//-------------------------keycap color adjust----------------------------
    const keycap_c = document.getElementById('keycap_color_chooser');
    keycap_c.addEventListener('input', () => {
        Keycap_color = keycap_c.value;
        if(dis_index == 'dis_Keycap')draw_with_keycap();
        else if(dis_index == 'dis_Led')draw_only_led();
    });

//-------------------------KB shell color adjust----------------------------
    const KB_shell_c = document.getElementById('kb_shell_color_chooser');
    KB_shell_c.addEventListener('input', () => {
        KB_shell_color = KB_shell_c.value;
        if(dis_index == 'dis_Keycap')draw_with_keycap();
        else if(dis_index == 'dis_Led')draw_only_led();
    });
//-------------------------BTN----------------------------
    const startBtn = document.getElementById('btn_ss');
    startBtn.onclick = function()
    {
        console.log(elec_max_row);
        console.log(elec_max_col);
        //console.log(B_value_src.join(" "));
        //console.log(R_value_src[3*11+6]);
        /*
        all_leds.forEach(row => {
            row.forEach(led => {
                const left = parseInt(led.style.left, 10);
                if(left <400)led.style.background = 'radial-gradient(circle closest-side, rgba(0,255,0,1), rgba(0,0,0,0))';
                else if(left <800)led.style.background = 'radial-gradient(circle closest-side, rgba(0,0,255,1), rgba(0,0,0,0))';
                else led.style.background = 'radial-gradient(circle closest-side, rgba(255,0,0,1), rgba(0,0,0,0))';

            });
        });*/

    };

    function draw_with_keycap() {

        const bar_edge_w = document.getElementById('bar_edge_w');
        keycap_light_edge_width = parseFloat(bar_edge_w.value);

        ctx.clearRect(0,0,ccanvas.offsetWidth, ccanvas.offsetHeight);
        Draw_background_color_mask();
        Draw_KB_shell();
        Draw_keycap_shadow();
        hollow_out_keycap_holes();
        Draw_keycap();
        hollow_out_keycap_words();
        ctx.restore();
        set_led_to_soft();
    }
    function draw_only_led() {
        keycap_light_edge_width = 0.1;
        ctx.clearRect(0,0,ccanvas.offsetWidth, ccanvas.offsetHeight);
        Draw_background_color_mask();
        Draw_KB_shell();
        hollow_out_keycap_holes();
        ctx.restore();
        set_led_to_solid();
    }

    function Draw_background_color_mask(){
    //-----------Draw background color mask, for the led light which is over the KB
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = mainBg;
        //ctx.fillStyle = 'rgb(200,0,200)';
        ctx.fillRect(0, 0, ccanvas.offsetWidth, ccanvas.offsetHeight);
        ctx.save();
    }

    function Draw_KB_shell(){
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = KB_shell_color;
        RoundRect(ctx,
                  led_light_cover,
                  led_light_cover,
                  keyboard.offsetWidth,
                  keyboard.offsetHeight,
                  20);
        ctx.save();
    }

    function Draw_keycap_shadow(){
        let rgb_temp;
        if (KB_shell_color.startsWith('#')) {
            rgb_temp = hexToRGB(KB_shell_color);
        }
        else if (KB_shell_color.startsWith('rgb')) {
            rgb_temp = KB_shell_color.match(/\d+/g).map(Number);
        }
        for (let i = 0; i < rgb_temp.length; i++)rgb_temp[i]*=0.7;

        const Keycap_shadow_color = `rgb(${rgb_temp[0]},${rgb_temp[1]},${rgb_temp[2]})`;
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = Keycap_shadow_color;
        all_keycaps.forEach(key => {
            RoundRect(ctx,
                      key.offsetLeft-keycap_light_edge_width+led_light_cover+3,
                      key.offsetTop-keycap_light_edge_width+led_light_cover+3,
                      key.offsetWidth+2*keycap_light_edge_width,
                      key.offsetHeight+2*keycap_light_edge_width,
                      keycap_round_rate);
        });
        ctx.save();
    }

    function hollow_out_keycap_holes(){
        if(keycap_light_edge_width != 0)
        {
            ctx.globalCompositeOperation = 'destination-out';
            all_keycaps.forEach(key => {
                RoundRect(ctx,
                          key.offsetLeft-keycap_light_edge_width+led_light_cover,
                          key.offsetTop-keycap_light_edge_width+led_light_cover,
                          key.offsetWidth+2*keycap_light_edge_width,
                          key.offsetHeight+2*keycap_light_edge_width,
                          keycap_round_rate);
            });
            ctx.save();
        }
    }

    function Draw_keycap(){
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = Keycap_color;
        all_keycaps.forEach(key => {
            let cap_r_temp = keycap_round_rate-keycap_light_edge_width;
            if(cap_r_temp < 0) cap_r_temp = 0;
            RoundRect(ctx, key.offsetLeft+led_light_cover, key.offsetTop+led_light_cover, key.offsetWidth, key.offsetHeight, cap_r_temp);
        });

        ctx.save();
    }

    function hollow_out_keycap_words(){
        ctx.globalCompositeOperation = 'destination-out';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        all_keycaps.forEach(key => {
            const lines = key.textContent.split(/\r?\n/); // \r\n 或 \n 都支援
            const x = key.offsetLeft + key.offsetWidth / 2+led_light_cover;
            const y = key.offsetTop + key.offsetHeight / 2+led_light_cover;
            const lineHeight = 16; // 每行間距，可以調整

            lines.forEach((line, i) => {
                ctx.fillText(line, x, y + i * lineHeight - (lines.length-1)*lineHeight/2);
            });
        });
        ctx.save();
    }

    function set_led_to_solid(){
        all_leds.flat().forEach(led_ => {
            led_.style.top  = led_.solidy + 'px';
            led_.style.left = led_.solidx + 'px';
            led_.style.width = led_solid_radius+'px';
            led_.style.height = led_solid_radius+'px';
        });
    }

    function set_led_to_soft(){
        all_leds.flat().forEach(led_ => {
            led_.style.top  = led_.softy + 'px';
            led_.style.left = led_.softx + 'px';
            led_.style.width = led_soft_radius*2+'px';
            led_.style.height = led_soft_radius*2+'px';
        });
    }

    function RoundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
    ctx.fill();
    }

    function hexToRGB(hex) {
        hex = hex.replace('#','');
        if(hex.length === 3){
            hex = hex.split('').map(c => c + c).join('');
        }
        const r = parseInt(hex.substr(0,2),16);
        const g = parseInt(hex.substr(2,2),16);
        const b = parseInt(hex.substr(4,2),16);
        return [r,g,b];

}
</script>

</body>
</html>
